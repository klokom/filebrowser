# slideserver/app.py

import os
import io
import hashlib # <--- THIS IS THE MISSING IMPORT
from flask import Flask, Response, abort, make_response, send_from_directory, jsonify
from openslide import OpenSlide, OpenSlideError
from openslide.deepzoom import DeepZoomGenerator

# Import our TIFF handler
from tiff_handler import generate_tiff_pyramid

app = Flask(__name__)

# --- Configuration ---
IMAGE_ROOT = "/srv/"
CACHE_ROOT = "/cache/"
DEEPZOOM_FORMAT = 'jpeg'

os.makedirs(CACHE_ROOT, exist_ok=True)

# --- DZI / Metadata Route ---
@app.route('/wsi/<path:filepath>.dzi')
def dzi(filepath):
    full_path = os.path.join(IMAGE_ROOT, filepath)
    if not os.path.exists(full_path):
        abort(404, "Source image not found.")

    try:
        # Try to open with OpenSlide first
        slide = OpenSlide(full_path)
        generator = DeepZoomGenerator(slide, tile_size=256, overlap=0, limit_bounds=True)
        resp = make_response(generator.get_dzi(DEEPZOOM_FORMAT))
        resp.mimetype = 'application/xml'
        print(f"Serving DZI for {os.path.basename(filepath)} from OpenSlide.")
        return resp
    except OpenSlideError:
        # If it's not a WSI file, use the TIFF handler to generate a static cache
        print(f"Not an OpenSlide file, using TIFF handler for {os.path.basename(filepath)}...")
        cache_dir = generate_tiff_pyramid(full_path, CACHE_ROOT)
        if cache_dir:
            file_basename = os.path.splitext(os.path.basename(filepath))[0]
            dzi_filename = f"{file_basename}.dzi"
            return send_from_directory(cache_dir, dzi_filename)
        else:
            # If the tiff_handler failed, abort.
            abort(500, "Failed to process TIFF file.")

# --- Tile Serving Route ---
@app.route('/wsi/<path:filepath>_files/<int:level>/<int:col>_<int:row>.<format>')
def tile(filepath, level, col, row, format):
    full_path = os.path.join(IMAGE_ROOT, filepath)
    if not os.path.exists(full_path):
        abort(404)

    try:
        # Try OpenSlide first for WSI tiles
        slide = OpenSlide(full_path)
        generator = DeepZoomGenerator(slide, tile_size=256, overlap=0, limit_bounds=True)
        tile = generator.get_tile(level, (col, row))
        
        buf = io.BytesIO()
        if tile.mode == 'RGBA':
            tile.save(buf, 'png')
            mimetype = 'image/png'
        else:
            tile.save(buf, DEEPZOOM_FORMAT, quality=90)
            mimetype = f'image/{DEEPZOOM_FORMAT}'
        
        return Response(buf.getvalue(), mimetype=mimetype)

    except OpenSlideError:
        # If it's not a WSI file, serve the tile from the static cache generated by pyvips
        image_hash = hashlib.md5(full_path.encode()).hexdigest()
        tile_dir_basename = f"{os.path.splitext(os.path.basename(filepath))[0]}_files"
        tile_filename = f"{col}_{row}.{format}"
        tile_path_in_cache = os.path.join(str(level), tile_filename)
        full_cache_dir = os.path.join(CACHE_ROOT, image_hash, tile_dir_basename)
        
        return send_from_directory(full_cache_dir, tile_path_in_cache)

# --- WSI Metadata Route (only works for OpenSlide files) ---
@app.route('/wsi/<path:filepath>.metadata')
def metadata(filepath):
    full_path = os.path.join(IMAGE_ROOT, filepath)
    try:
        slide = OpenSlide(full_path)
        props = dict(slide.properties)
        return jsonify(props)
    except OpenSlideError:
        abort(404, description="Metadata is only available for OpenSlide-compatible formats.")